Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program programs
Rule 2     programs -> program
Rule 3     program -> statement
Rule 4     program -> expression
Rule 5     statement -> PRINT ( expression )
Rule 6     statement -> LET IDENTIFIER : type !
Rule 7     statement -> LET IDENTIFIER : type ! = expression
Rule 8     statement -> LET IDENTIFIER : type ! = NIL
Rule 9     statement -> LET IDENTIFIER : type ?
Rule 10    statement -> LET IDENTIFIER : type ? = expression
Rule 11    statement -> LET IDENTIFIER : type ? = NIL
Rule 12    statement -> LET IDENTIFIER : type
Rule 13    statement -> LET IDENTIFIER : type = expression
Rule 14    statement -> IDENTIFIER = expression
Rule 15    statement -> IDENTIFIER = NIL
Rule 16    statement -> LET IDENTIFIER = expression
Rule 17    statement -> expression
Rule 18    expression -> LSTRING BSLASH expression RSTRING
Rule 19    expression -> expression ? ? expression
Rule 20    expression -> expression + expression
Rule 21    expression -> expression - expression
Rule 22    expression -> expression * expression
Rule 23    expression -> expression / expression
Rule 24    expression -> STRING
Rule 25    expression -> INTEGER
Rule 26    expression -> IDENTIFIER
Rule 27    type -> INT
Rule 28    type -> SSTRING

Terminals, with rules where they appear

!                    : 6 7 8
(                    : 5
)                    : 5
*                    : 22
+                    : 20
-                    : 21
/                    : 23
:                    : 6 7 8 9 10 11 12 13
=                    : 7 8 10 11 13 14 15 16
?                    : 9 10 11 19 19
BSLASH               : 18
IDENTIFIER           : 6 7 8 9 10 11 12 13 14 15 16 26
INT                  : 27
INTEGER              : 25
LET                  : 6 7 8 9 10 11 12 13 16
LSTRING              : 18
NIL                  : 8 11 15
PRINT                : 5
RSTRING              : 18
SSTRING              : 28
STRING               : 24
error                : 

Nonterminals, with rules where they appear

expression           : 4 5 7 10 13 14 16 17 18 19 19 20 20 21 21 22 22 23 23
program              : 1 2 0
programs             : 1
statement            : 3
type                 : 6 7 8 9 10 11 12 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program programs
    (3) program -> . statement
    (4) program -> . expression
    (5) statement -> . PRINT ( expression )
    (6) statement -> . LET IDENTIFIER : type !
    (7) statement -> . LET IDENTIFIER : type ! = expression
    (8) statement -> . LET IDENTIFIER : type ! = NIL
    (9) statement -> . LET IDENTIFIER : type ?
    (10) statement -> . LET IDENTIFIER : type ? = expression
    (11) statement -> . LET IDENTIFIER : type ? = NIL
    (12) statement -> . LET IDENTIFIER : type
    (13) statement -> . LET IDENTIFIER : type = expression
    (14) statement -> . IDENTIFIER = expression
    (15) statement -> . IDENTIFIER = NIL
    (16) statement -> . LET IDENTIFIER = expression
    (17) statement -> . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    PRINT           shift and go to state 1
    LET             shift and go to state 9
    IDENTIFIER      shift and go to state 4
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6

    expression                     shift and go to state 7
    program                        shift and go to state 2
    statement                      shift and go to state 3

state 1

    (5) statement -> PRINT . ( expression )

    (               shift and go to state 10


state 2

    (0) S' -> program .
    (1) program -> program . programs
    (2) programs -> . program
    (1) program -> . program programs
    (3) program -> . statement
    (4) program -> . expression
    (5) statement -> . PRINT ( expression )
    (6) statement -> . LET IDENTIFIER : type !
    (7) statement -> . LET IDENTIFIER : type ! = expression
    (8) statement -> . LET IDENTIFIER : type ! = NIL
    (9) statement -> . LET IDENTIFIER : type ?
    (10) statement -> . LET IDENTIFIER : type ? = expression
    (11) statement -> . LET IDENTIFIER : type ? = NIL
    (12) statement -> . LET IDENTIFIER : type
    (13) statement -> . LET IDENTIFIER : type = expression
    (14) statement -> . IDENTIFIER = expression
    (15) statement -> . IDENTIFIER = NIL
    (16) statement -> . LET IDENTIFIER = expression
    (17) statement -> . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    PRINT           shift and go to state 1
    LET             shift and go to state 9
    IDENTIFIER      shift and go to state 4
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6

    expression                     shift and go to state 7
    program                        shift and go to state 11
    statement                      shift and go to state 3
    programs                       shift and go to state 12

state 3

    (3) program -> statement .

    PRINT           reduce using rule 3 (program -> statement .)
    LET             reduce using rule 3 (program -> statement .)
    IDENTIFIER      reduce using rule 3 (program -> statement .)
    LSTRING         reduce using rule 3 (program -> statement .)
    STRING          reduce using rule 3 (program -> statement .)
    INTEGER         reduce using rule 3 (program -> statement .)
    $end            reduce using rule 3 (program -> statement .)


state 4

    (14) statement -> IDENTIFIER . = expression
    (15) statement -> IDENTIFIER . = NIL
    (26) expression -> IDENTIFIER .

    =               shift and go to state 13
    ?               reduce using rule 26 (expression -> IDENTIFIER .)
    +               reduce using rule 26 (expression -> IDENTIFIER .)
    -               reduce using rule 26 (expression -> IDENTIFIER .)
    *               reduce using rule 26 (expression -> IDENTIFIER .)
    /               reduce using rule 26 (expression -> IDENTIFIER .)
    PRINT           reduce using rule 26 (expression -> IDENTIFIER .)
    LET             reduce using rule 26 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 26 (expression -> IDENTIFIER .)
    LSTRING         reduce using rule 26 (expression -> IDENTIFIER .)
    STRING          reduce using rule 26 (expression -> IDENTIFIER .)
    INTEGER         reduce using rule 26 (expression -> IDENTIFIER .)
    $end            reduce using rule 26 (expression -> IDENTIFIER .)


state 5

    (18) expression -> LSTRING . BSLASH expression RSTRING

    BSLASH          shift and go to state 14


state 6

    (25) expression -> INTEGER .

    ?               reduce using rule 25 (expression -> INTEGER .)
    +               reduce using rule 25 (expression -> INTEGER .)
    -               reduce using rule 25 (expression -> INTEGER .)
    *               reduce using rule 25 (expression -> INTEGER .)
    /               reduce using rule 25 (expression -> INTEGER .)
    PRINT           reduce using rule 25 (expression -> INTEGER .)
    LET             reduce using rule 25 (expression -> INTEGER .)
    IDENTIFIER      reduce using rule 25 (expression -> INTEGER .)
    LSTRING         reduce using rule 25 (expression -> INTEGER .)
    STRING          reduce using rule 25 (expression -> INTEGER .)
    INTEGER         reduce using rule 25 (expression -> INTEGER .)
    $end            reduce using rule 25 (expression -> INTEGER .)
    )               reduce using rule 25 (expression -> INTEGER .)
    RSTRING         reduce using rule 25 (expression -> INTEGER .)


state 7

    (4) program -> expression .
    (17) statement -> expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! reduce/reduce conflict for PRINT resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for LET resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for LSTRING resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for STRING resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for INTEGER resolved using rule 4 (program -> expression .)
  ! reduce/reduce conflict for $end resolved using rule 4 (program -> expression .)
    PRINT           reduce using rule 4 (program -> expression .)
    LET             reduce using rule 4 (program -> expression .)
    IDENTIFIER      reduce using rule 4 (program -> expression .)
    LSTRING         reduce using rule 4 (program -> expression .)
    STRING          reduce using rule 4 (program -> expression .)
    INTEGER         reduce using rule 4 (program -> expression .)
    $end            reduce using rule 4 (program -> expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! PRINT           [ reduce using rule 17 (statement -> expression .) ]
  ! LET             [ reduce using rule 17 (statement -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 17 (statement -> expression .) ]
  ! LSTRING         [ reduce using rule 17 (statement -> expression .) ]
  ! STRING          [ reduce using rule 17 (statement -> expression .) ]
  ! INTEGER         [ reduce using rule 17 (statement -> expression .) ]
  ! $end            [ reduce using rule 17 (statement -> expression .) ]


state 8

    (24) expression -> STRING .

    ?               reduce using rule 24 (expression -> STRING .)
    +               reduce using rule 24 (expression -> STRING .)
    -               reduce using rule 24 (expression -> STRING .)
    *               reduce using rule 24 (expression -> STRING .)
    /               reduce using rule 24 (expression -> STRING .)
    PRINT           reduce using rule 24 (expression -> STRING .)
    LET             reduce using rule 24 (expression -> STRING .)
    IDENTIFIER      reduce using rule 24 (expression -> STRING .)
    LSTRING         reduce using rule 24 (expression -> STRING .)
    STRING          reduce using rule 24 (expression -> STRING .)
    INTEGER         reduce using rule 24 (expression -> STRING .)
    $end            reduce using rule 24 (expression -> STRING .)
    )               reduce using rule 24 (expression -> STRING .)
    RSTRING         reduce using rule 24 (expression -> STRING .)


state 9

    (6) statement -> LET . IDENTIFIER : type !
    (7) statement -> LET . IDENTIFIER : type ! = expression
    (8) statement -> LET . IDENTIFIER : type ! = NIL
    (9) statement -> LET . IDENTIFIER : type ?
    (10) statement -> LET . IDENTIFIER : type ? = expression
    (11) statement -> LET . IDENTIFIER : type ? = NIL
    (12) statement -> LET . IDENTIFIER : type
    (13) statement -> LET . IDENTIFIER : type = expression
    (16) statement -> LET . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 20


state 10

    (5) statement -> PRINT ( . expression )
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 21

state 11

    (2) programs -> program .
    (1) program -> program . programs
    (2) programs -> . program
    (1) program -> . program programs
    (3) program -> . statement
    (4) program -> . expression
    (5) statement -> . PRINT ( expression )
    (6) statement -> . LET IDENTIFIER : type !
    (7) statement -> . LET IDENTIFIER : type ! = expression
    (8) statement -> . LET IDENTIFIER : type ! = NIL
    (9) statement -> . LET IDENTIFIER : type ?
    (10) statement -> . LET IDENTIFIER : type ? = expression
    (11) statement -> . LET IDENTIFIER : type ? = NIL
    (12) statement -> . LET IDENTIFIER : type
    (13) statement -> . LET IDENTIFIER : type = expression
    (14) statement -> . IDENTIFIER = expression
    (15) statement -> . IDENTIFIER = NIL
    (16) statement -> . LET IDENTIFIER = expression
    (17) statement -> . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LSTRING resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
    $end            reduce using rule 2 (programs -> program .)
    PRINT           shift and go to state 1
    LET             shift and go to state 9
    IDENTIFIER      shift and go to state 4
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6

  ! PRINT           [ reduce using rule 2 (programs -> program .) ]
  ! LET             [ reduce using rule 2 (programs -> program .) ]
  ! IDENTIFIER      [ reduce using rule 2 (programs -> program .) ]
  ! LSTRING         [ reduce using rule 2 (programs -> program .) ]
  ! STRING          [ reduce using rule 2 (programs -> program .) ]
  ! INTEGER         [ reduce using rule 2 (programs -> program .) ]

    expression                     shift and go to state 7
    program                        shift and go to state 11
    statement                      shift and go to state 3
    programs                       shift and go to state 12

state 12

    (1) program -> program programs .

    PRINT           reduce using rule 1 (program -> program programs .)
    LET             reduce using rule 1 (program -> program programs .)
    IDENTIFIER      reduce using rule 1 (program -> program programs .)
    LSTRING         reduce using rule 1 (program -> program programs .)
    STRING          reduce using rule 1 (program -> program programs .)
    INTEGER         reduce using rule 1 (program -> program programs .)
    $end            reduce using rule 1 (program -> program programs .)


state 13

    (14) statement -> IDENTIFIER = . expression
    (15) statement -> IDENTIFIER = . NIL
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    NIL             shift and go to state 24
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 23

state 14

    (18) expression -> LSTRING BSLASH . expression RSTRING
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 25

state 15

    (22) expression -> expression * . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 26

state 16

    (20) expression -> expression + . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 27

state 17

    (21) expression -> expression - . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 28

state 18

    (23) expression -> expression / . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 29

state 19

    (19) expression -> expression ? . ? expression

    ?               shift and go to state 30


state 20

    (6) statement -> LET IDENTIFIER . : type !
    (7) statement -> LET IDENTIFIER . : type ! = expression
    (8) statement -> LET IDENTIFIER . : type ! = NIL
    (9) statement -> LET IDENTIFIER . : type ?
    (10) statement -> LET IDENTIFIER . : type ? = expression
    (11) statement -> LET IDENTIFIER . : type ? = NIL
    (12) statement -> LET IDENTIFIER . : type
    (13) statement -> LET IDENTIFIER . : type = expression
    (16) statement -> LET IDENTIFIER . = expression

    :               shift and go to state 31
    =               shift and go to state 32


state 21

    (5) statement -> PRINT ( expression . )
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    )               shift and go to state 33
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18


state 22

    (26) expression -> IDENTIFIER .

    ?               reduce using rule 26 (expression -> IDENTIFIER .)
    +               reduce using rule 26 (expression -> IDENTIFIER .)
    -               reduce using rule 26 (expression -> IDENTIFIER .)
    *               reduce using rule 26 (expression -> IDENTIFIER .)
    /               reduce using rule 26 (expression -> IDENTIFIER .)
    PRINT           reduce using rule 26 (expression -> IDENTIFIER .)
    LET             reduce using rule 26 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 26 (expression -> IDENTIFIER .)
    LSTRING         reduce using rule 26 (expression -> IDENTIFIER .)
    STRING          reduce using rule 26 (expression -> IDENTIFIER .)
    INTEGER         reduce using rule 26 (expression -> IDENTIFIER .)
    $end            reduce using rule 26 (expression -> IDENTIFIER .)
    )               reduce using rule 26 (expression -> IDENTIFIER .)
    RSTRING         reduce using rule 26 (expression -> IDENTIFIER .)


state 23

    (14) statement -> IDENTIFIER = expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    PRINT           reduce using rule 14 (statement -> IDENTIFIER = expression .)
    LET             reduce using rule 14 (statement -> IDENTIFIER = expression .)
    IDENTIFIER      reduce using rule 14 (statement -> IDENTIFIER = expression .)
    LSTRING         reduce using rule 14 (statement -> IDENTIFIER = expression .)
    STRING          reduce using rule 14 (statement -> IDENTIFIER = expression .)
    INTEGER         reduce using rule 14 (statement -> IDENTIFIER = expression .)
    $end            reduce using rule 14 (statement -> IDENTIFIER = expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18


state 24

    (15) statement -> IDENTIFIER = NIL .

    PRINT           reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    LET             reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    IDENTIFIER      reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    LSTRING         reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    STRING          reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    INTEGER         reduce using rule 15 (statement -> IDENTIFIER = NIL .)
    $end            reduce using rule 15 (statement -> IDENTIFIER = NIL .)


state 25

    (18) expression -> LSTRING BSLASH expression . RSTRING
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    RSTRING         shift and go to state 34
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18


state 26

    (22) expression -> expression * expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    PRINT           reduce using rule 22 (expression -> expression * expression .)
    LET             reduce using rule 22 (expression -> expression * expression .)
    IDENTIFIER      reduce using rule 22 (expression -> expression * expression .)
    LSTRING         reduce using rule 22 (expression -> expression * expression .)
    STRING          reduce using rule 22 (expression -> expression * expression .)
    INTEGER         reduce using rule 22 (expression -> expression * expression .)
    $end            reduce using rule 22 (expression -> expression * expression .)
    )               reduce using rule 22 (expression -> expression * expression .)
    RSTRING         reduce using rule 22 (expression -> expression * expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! ?               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! +               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! -               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! *               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! /               [ reduce using rule 22 (expression -> expression * expression .) ]


state 27

    (20) expression -> expression + expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    PRINT           reduce using rule 20 (expression -> expression + expression .)
    LET             reduce using rule 20 (expression -> expression + expression .)
    IDENTIFIER      reduce using rule 20 (expression -> expression + expression .)
    LSTRING         reduce using rule 20 (expression -> expression + expression .)
    STRING          reduce using rule 20 (expression -> expression + expression .)
    INTEGER         reduce using rule 20 (expression -> expression + expression .)
    $end            reduce using rule 20 (expression -> expression + expression .)
    )               reduce using rule 20 (expression -> expression + expression .)
    RSTRING         reduce using rule 20 (expression -> expression + expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! ?               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! +               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! -               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! *               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 20 (expression -> expression + expression .) ]


state 28

    (21) expression -> expression - expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    PRINT           reduce using rule 21 (expression -> expression - expression .)
    LET             reduce using rule 21 (expression -> expression - expression .)
    IDENTIFIER      reduce using rule 21 (expression -> expression - expression .)
    LSTRING         reduce using rule 21 (expression -> expression - expression .)
    STRING          reduce using rule 21 (expression -> expression - expression .)
    INTEGER         reduce using rule 21 (expression -> expression - expression .)
    $end            reduce using rule 21 (expression -> expression - expression .)
    )               reduce using rule 21 (expression -> expression - expression .)
    RSTRING         reduce using rule 21 (expression -> expression - expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! ?               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! +               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! -               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! *               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 21 (expression -> expression - expression .) ]


state 29

    (23) expression -> expression / expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    PRINT           reduce using rule 23 (expression -> expression / expression .)
    LET             reduce using rule 23 (expression -> expression / expression .)
    IDENTIFIER      reduce using rule 23 (expression -> expression / expression .)
    LSTRING         reduce using rule 23 (expression -> expression / expression .)
    STRING          reduce using rule 23 (expression -> expression / expression .)
    INTEGER         reduce using rule 23 (expression -> expression / expression .)
    $end            reduce using rule 23 (expression -> expression / expression .)
    )               reduce using rule 23 (expression -> expression / expression .)
    RSTRING         reduce using rule 23 (expression -> expression / expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! ?               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! +               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! -               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! *               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! /               [ reduce using rule 23 (expression -> expression / expression .) ]


state 30

    (19) expression -> expression ? ? . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 35

state 31

    (6) statement -> LET IDENTIFIER : . type !
    (7) statement -> LET IDENTIFIER : . type ! = expression
    (8) statement -> LET IDENTIFIER : . type ! = NIL
    (9) statement -> LET IDENTIFIER : . type ?
    (10) statement -> LET IDENTIFIER : . type ? = expression
    (11) statement -> LET IDENTIFIER : . type ? = NIL
    (12) statement -> LET IDENTIFIER : . type
    (13) statement -> LET IDENTIFIER : . type = expression
    (27) type -> . INT
    (28) type -> . SSTRING

    INT             shift and go to state 38
    SSTRING         shift and go to state 36

    type                           shift and go to state 37

state 32

    (16) statement -> LET IDENTIFIER = . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 39

state 33

    (5) statement -> PRINT ( expression ) .

    PRINT           reduce using rule 5 (statement -> PRINT ( expression ) .)
    LET             reduce using rule 5 (statement -> PRINT ( expression ) .)
    IDENTIFIER      reduce using rule 5 (statement -> PRINT ( expression ) .)
    LSTRING         reduce using rule 5 (statement -> PRINT ( expression ) .)
    STRING          reduce using rule 5 (statement -> PRINT ( expression ) .)
    INTEGER         reduce using rule 5 (statement -> PRINT ( expression ) .)
    $end            reduce using rule 5 (statement -> PRINT ( expression ) .)


state 34

    (18) expression -> LSTRING BSLASH expression RSTRING .

    ?               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    +               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    -               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    *               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    /               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    PRINT           reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    LET             reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    IDENTIFIER      reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    LSTRING         reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    STRING          reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    INTEGER         reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    $end            reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    )               reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)
    RSTRING         reduce using rule 18 (expression -> LSTRING BSLASH expression RSTRING .)


state 35

    (19) expression -> expression ? ? expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    PRINT           reduce using rule 19 (expression -> expression ? ? expression .)
    LET             reduce using rule 19 (expression -> expression ? ? expression .)
    IDENTIFIER      reduce using rule 19 (expression -> expression ? ? expression .)
    LSTRING         reduce using rule 19 (expression -> expression ? ? expression .)
    STRING          reduce using rule 19 (expression -> expression ? ? expression .)
    INTEGER         reduce using rule 19 (expression -> expression ? ? expression .)
    $end            reduce using rule 19 (expression -> expression ? ? expression .)
    )               reduce using rule 19 (expression -> expression ? ? expression .)
    RSTRING         reduce using rule 19 (expression -> expression ? ? expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18

  ! ?               [ reduce using rule 19 (expression -> expression ? ? expression .) ]
  ! +               [ reduce using rule 19 (expression -> expression ? ? expression .) ]
  ! -               [ reduce using rule 19 (expression -> expression ? ? expression .) ]
  ! *               [ reduce using rule 19 (expression -> expression ? ? expression .) ]
  ! /               [ reduce using rule 19 (expression -> expression ? ? expression .) ]


state 36

    (28) type -> SSTRING .

    !               reduce using rule 28 (type -> SSTRING .)
    ?               reduce using rule 28 (type -> SSTRING .)
    =               reduce using rule 28 (type -> SSTRING .)
    PRINT           reduce using rule 28 (type -> SSTRING .)
    LET             reduce using rule 28 (type -> SSTRING .)
    IDENTIFIER      reduce using rule 28 (type -> SSTRING .)
    LSTRING         reduce using rule 28 (type -> SSTRING .)
    STRING          reduce using rule 28 (type -> SSTRING .)
    INTEGER         reduce using rule 28 (type -> SSTRING .)
    $end            reduce using rule 28 (type -> SSTRING .)


state 37

    (6) statement -> LET IDENTIFIER : type . !
    (7) statement -> LET IDENTIFIER : type . ! = expression
    (8) statement -> LET IDENTIFIER : type . ! = NIL
    (9) statement -> LET IDENTIFIER : type . ?
    (10) statement -> LET IDENTIFIER : type . ? = expression
    (11) statement -> LET IDENTIFIER : type . ? = NIL
    (12) statement -> LET IDENTIFIER : type .
    (13) statement -> LET IDENTIFIER : type . = expression

    !               shift and go to state 40
    ?               shift and go to state 42
    PRINT           reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    LET             reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    IDENTIFIER      reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    LSTRING         reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    STRING          reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    INTEGER         reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    $end            reduce using rule 12 (statement -> LET IDENTIFIER : type .)
    =               shift and go to state 41


state 38

    (27) type -> INT .

    !               reduce using rule 27 (type -> INT .)
    ?               reduce using rule 27 (type -> INT .)
    =               reduce using rule 27 (type -> INT .)
    PRINT           reduce using rule 27 (type -> INT .)
    LET             reduce using rule 27 (type -> INT .)
    IDENTIFIER      reduce using rule 27 (type -> INT .)
    LSTRING         reduce using rule 27 (type -> INT .)
    STRING          reduce using rule 27 (type -> INT .)
    INTEGER         reduce using rule 27 (type -> INT .)
    $end            reduce using rule 27 (type -> INT .)


state 39

    (16) statement -> LET IDENTIFIER = expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    PRINT           reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    LET             reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    IDENTIFIER      reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    LSTRING         reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    STRING          reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    INTEGER         reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    $end            reduce using rule 16 (statement -> LET IDENTIFIER = expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18


state 40

    (6) statement -> LET IDENTIFIER : type ! .
    (7) statement -> LET IDENTIFIER : type ! . = expression
    (8) statement -> LET IDENTIFIER : type ! . = NIL

    PRINT           reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    LET             reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    IDENTIFIER      reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    LSTRING         reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    STRING          reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    INTEGER         reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    $end            reduce using rule 6 (statement -> LET IDENTIFIER : type ! .)
    =               shift and go to state 43


state 41

    (13) statement -> LET IDENTIFIER : type = . expression
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 44

state 42

    (9) statement -> LET IDENTIFIER : type ? .
    (10) statement -> LET IDENTIFIER : type ? . = expression
    (11) statement -> LET IDENTIFIER : type ? . = NIL

    PRINT           reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    LET             reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    IDENTIFIER      reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    LSTRING         reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    STRING          reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    INTEGER         reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    $end            reduce using rule 9 (statement -> LET IDENTIFIER : type ? .)
    =               shift and go to state 45


state 43

    (7) statement -> LET IDENTIFIER : type ! = . expression
    (8) statement -> LET IDENTIFIER : type ! = . NIL
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    NIL             shift and go to state 47
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 46

state 44

    (13) statement -> LET IDENTIFIER : type = expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    PRINT           reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    LET             reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    IDENTIFIER      reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    LSTRING         reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    STRING          reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    INTEGER         reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    $end            reduce using rule 13 (statement -> LET IDENTIFIER : type = expression .)
    ?               shift and go to state 19
    +               shift and go to state 16
    -               shift and go to state 17
    *               shift and go to state 15
    /               shift and go to state 18


state 45

    (10) statement -> LET IDENTIFIER : type ? = . expression
    (11) statement -> LET IDENTIFIER : type ? = . NIL
    (18) expression -> . LSTRING BSLASH expression RSTRING
    (19) expression -> . expression ? ? expression
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . STRING
    (25) expression -> . INTEGER
    (26) expression -> . IDENTIFIER

    NIL             shift and go to state 49
    LSTRING         shift and go to state 5
    STRING          shift and go to state 8
    INTEGER         shift and go to state 6
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 48

state 46

    (7) statement -> LET IDENTIFIER : type ! = expression .
    (19) expression -> expression . ? ? expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression

    PRINT           reduce using rule 7 (statement -> LET IDENTIFIER : type ! = expression .)
    LET             reduce using rule 7 (statement -> LET IDENTIFIER : type ! = expression .)
    IDENTIFIER      reduce using rule 7 (statement -> LET IDENTIFIER : type ! = expression .)
    LSTRING         reduce using rule 7 (statement -> LET IDENTIFIER : type ! = expression .)
    STRING          reduce 